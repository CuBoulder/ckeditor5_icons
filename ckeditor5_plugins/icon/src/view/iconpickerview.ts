/**
 * @file contains the icon picker root view.
 */

import type { ViewCollection, FocusableView, ButtonExecuteEvent } from 'ckeditor5/src/ui';
import { View, FocusCycler } from 'ckeditor5/src/ui';
import type { Locale } from 'ckeditor5/src/utils';
import { FocusTracker, KeystrokeHandler } from 'ckeditor5/src/utils';
import { getValidIconStyle } from '../iconutils';
import type { FontAwesomeStyle, FontAwesomeVersion, CategoryDefinitions, IconDefinition, IconDefinitions, IconName } from '../icontypes';
import IconPickerHeader from './iconpickerheader';
import IconPickerGrid from './iconpickergrid';
import IconPickerFooter from './iconpickerfooter';
import type { CategorySelectionEvent } from './iconpickerheader';
import type { IconSelectionEvent, GridSectionLoadEvent } from './iconpickergrid';
import type { SearchEvent } from './iconpickersearch';
import type { ChangeStyleEvent } from './iconpickerform';

export default class IconPickerView extends View implements FocusableView {
	/**
	 * The name of the currently selected icon.
	 * 
	 * @observable
	 */
	public declare iconName: IconName | null;

	/**
	 * The selected style of the currently selected icon.
	 * 
	 * @observable
	 */
	public declare iconStyle: FontAwesomeStyle | null;

	/**
	 * The definition of the currently selected icon.
	 * 
	 * @observable
	 */
	public declare iconDefinition: IconDefinition | null;

	/**
	 * The icon picker header view.
	 */
	private readonly headerView: IconPickerHeader;

	/**
	 * The icon picker scrollable grid view.
	 */
	private readonly gridView: IconPickerGrid;

	/**
	 * The icon picker footer view.
	 */
	private readonly footerView: IconPickerFooter;

	/**
	 * The search field input view.
	 */
	private readonly searchFieldView: FocusableView;

	/**
	 * The items for which to track focus (tab or shift + tab).
	 */
	private readonly items: ViewCollection;

	/**
	 * The focus tracker.
	 */
	private readonly focusTracker: FocusTracker;

	/**
	 * The keystroke handler.
	 */
	private readonly keystrokes: KeystrokeHandler;

	/**
	 * Constructs a new IconPickerView.
	 * 
	 * @param locale
	 *   The locale.
	 * @param faVersion
	 *   The version of Font Awesome being used.
	 * @param faCategories
	 *   The Font Awesome category definitions.
	 * @param faIcons
	 *   The Font Awesome icon definitions.
	 * @param faStyles
	 *   The enabled Font Awesome icon styles.
	 * @param recommendedIcons
	 *   The icons to display in the recommended category.
	 */
	public constructor(locale: Locale, faVersion: FontAwesomeVersion, faCategories: CategoryDefinitions, faIcons: IconDefinitions, faStyles: FontAwesomeStyle[], recommendedIcons: IconName[] | null | undefined) {
		super(locale);

		this.set('iconName', null);
		this.set('iconStyle', null);
		this.set('iconDefinition', null);

		this.headerView = new IconPickerHeader(locale, faCategories, faStyles, recommendedIcons);
		this.gridView = new IconPickerGrid(locale, faVersion);
		this.footerView = new IconPickerFooter(locale, faVersion);
		this.searchFieldView = this.footerView.searchView.searchFieldView.fieldView;
		const searchClearButtonView = this.footerView.searchView.clearButtonView;

		this.items = this.createCollection();
		this.focusTracker = new FocusTracker();
		this.keystrokes = new KeystrokeHandler();

		new FocusCycler({
			focusables: this.items,
			focusTracker: this.focusTracker,
			keystrokeHandler: this.keystrokes,
			actions: {
				focusPrevious: 'shift + tab',
				focusNext: 'tab'
			}
		});

		this.setTemplate({
			tag: 'div',
			children: [this.headerView, this.gridView, this.footerView],
			attributes: {
				// Avoid focus loss when the user clicks the area of the grid that is not a button.
				// https://github.com/ckeditor/ckeditor5/pull/12319#issuecomment-1231779819
				tabindex: '-1'
			}
		});

		this.items.add(this.headerView);
		this.items.add(this.gridView);

		// === Events generated by the different subviews are handled here. ===

		// Handles the category change event from the header.
		this.listenTo<CategorySelectionEvent>(this.headerView, 'execute', (_eventInfo, categoryName, categoryDefinition) => {
			this.set('iconName', null);
			this.set('iconDefinition', null);
			this.gridView.refresh(categoryName, categoryDefinition, faIcons);
			this.footerView.refresh();
			this._stopTrackingFooterForm();
		});

		// Handles the icon selection event from the grid.
		this.listenTo<IconSelectionEvent>(this.gridView, 'execute', (_eventInfo, iconName, iconDefinition) => {
			this.set('iconName', iconName);
			this.set('iconStyle', getValidIconStyle(iconDefinition, this.iconStyle));
			this.set('iconDefinition', iconDefinition);
			this.footerView.refresh();
			this._startTrackingFooterForm();
		});

		// Tracks the "Show more" button in the grid view.
		this.listenTo<GridSectionLoadEvent>(this.gridView, 'gridSectionLoad', (_eventInfo, expandButtonVisible) => {
			if (expandButtonVisible)
				this._startTracking(this.gridView.expandButtonView, this.items.getIndex(this.searchFieldView));
			else this._stopTracking(this.gridView.expandButtonView);
		});

		// Handles the search event.
		this.listenTo<SearchEvent>(this.footerView, 'search', (_eventInfo, searchQuery) => {
			if (this.iconName) {
				this.set('iconName', null);
				this.set('iconDefinition', null);
				this.footerView.refresh();
				this._stopTrackingFooterForm();
			}
			if (searchQuery) {
				this.gridView.refresh('_all', faCategories['_all']!, faIcons, searchQuery);
				this.headerView.categoryDropdownView.buttonView.set('isVisible', false);
				this._stopTracking(this.headerView);
				searchClearButtonView.isVisible = true;
				this._startTracking(searchClearButtonView);
			} else {
				this.gridView.refresh(this.headerView.categoryName || '_all', this.headerView.categoryDefinition || faCategories['_all']!, faIcons);
				this.headerView.categoryDropdownView.buttonView.set('isVisible', true);
				this._startTracking(this.headerView, 0);
				searchClearButtonView.isVisible = false;
				this._stopTracking(searchClearButtonView);
			}
		});

		// Handles the icon style change event.
		this.listenTo<ChangeStyleEvent>(this.footerView, 'changeStyle', (_eventInfo, iconStyle) => {
			this.set('iconStyle', iconStyle);
			this.footerView.refresh();
		});

		// Handles the icon insert cancel event.
		this.on('cancel', _eventInfo => this._clearSelectedIcon(true));

		// Fires the icon insert cancel event if the Escape key is pressed with an icon selected.
		// If an icon is not selected or Escape is pressed twice, the default behavior is to close the icon picker.
		this.keystrokes.set('Esc', (_data, cancel) => {
			if (this.iconName) {
				this._clearSelectedIcon(true);
				cancel();
			} else if (this.items.has(searchClearButtonView)) {
				searchClearButtonView.fire<ButtonExecuteEvent>('execute'); // Escape key mimics a press of "Clear search".
				cancel();
			}
		});

		// Binds values that need to be avaliable in the different subviews so they remain in sync with the main view.
		this.gridView.bind('iconName', 'iconStyle').to(this);
		this.footerView.bind('iconName', 'iconStyle', 'iconDefinition').to(this);

		// Ensures the `execute` and `cancel` events of the icon picker view fires when someone confirms an icon insert.
		this.footerView.on('execute', () => {
			this.fire<InsertIconEvent>('execute', this.iconName!, this.iconStyle!);
			this._clearSelectedIcon();
		});
		this.footerView.delegate('cancel').to(this);

		// Fires the initial event to populate the grid view.
		if (faCategories['_recommended'])
			this.headerView.fire<CategorySelectionEvent>('execute', '_recommended', faCategories['_recommended']);
		else this.headerView.fire<CategorySelectionEvent>('execute', '_all', faCategories['_all']!);
	}

	/**
	 * Starts tracking a view's focus.
	 * 
	 * @param view
	 *   The view to start tracking.
	 * @param index
	 *   The index at which to track the view (should match the order it appears in the interface).
	 */
	private _startTracking(view: View, index?: number) {
		if (!this.items.has(view)) {
			this.items.add(view, index);
			this.focusTracker.add(view.element!);
		}
	}

	/**
	 * Stops tracking a view's focus.
	 * 
	 * @param view
	 *   The view to stop tracking.
	 */
	private _stopTracking(view: View) {
		if (this.items.has(view)) {
			this.items.remove(view);
			this.focusTracker.remove(view.element!);
		}
	}

	private _startTrackingFooterForm() {
		this._stopTracking(this.searchFieldView);
		this._startTracking(this.footerView.formView.styleDropdownView.buttonView);
		this._startTracking(this.footerView.formView.submitButtonView);
		this._startTracking(this.footerView.formView.cancelButtonView);
	}

	private _stopTrackingFooterForm() {
		this._stopTracking(this.footerView.formView.styleDropdownView.buttonView);
		this._stopTracking(this.footerView.formView.submitButtonView);
		this._stopTracking(this.footerView.formView.cancelButtonView);
		this._startTracking(this.searchFieldView);
	}

	/**
	 * Clears the selected icon.
	 * 
	 * @param refocus
	 *   Whether to refocus away from the form if necessary.
	 */
	private _clearSelectedIcon(refocus: boolean = false) {
		if (refocus && this.focusTracker.isFocused && this.focusTracker.focusedElement?.parentElement === this.footerView.formView.element)
			this.gridView.focus();
		this.set('iconName', null);
		this.set('iconDefinition', null);
		this.footerView.refresh();
		this._stopTrackingFooterForm();
	}

	/**
	 * @inheritdoc
	 */
	public override render() {
		super.render();

		this.focusTracker.add(this.headerView.element!);
		this.focusTracker.add(this.gridView.element!);

		// Start listening for the keystrokes coming from #element.
		this.keystrokes.listenTo(this.element!);
	}

	/**
	 * @inheritdoc
	 */
	public override destroy() {
		super.destroy();

		this.focusTracker.destroy();
		this.keystrokes.destroy();
	}

	/**
	 * Focuses the first focusable in `items`.
	 */
	public focus() {
		if (this.items.has(this.searchFieldView))
			this.searchFieldView.focus();
		else this.headerView.focus();
	}
}

/**
 * The event fired when "Insert" is clicked to insert the icon.
 */
export type InsertIconEvent = {
	name: 'execute';
	args: [iconName: IconName, iconStyle: FontAwesomeStyle];
};
